pipeline {
    agent any
    
    // Production-grade options
    options {
        timeout(time: 15, unit: 'MINUTES')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        skipDefaultCheckout()
    }
    
    // Environment variables
    environment {
        APP_NAME = 'k8s-commander'
        BUILD_TIMESTAMP = "${new Date().format('yyyyMMdd-HHmmss')}"
    }
    
    // K8s Commander parameters
    parameters {
        choice(
            name: 'K8S_CONCEPT',
            choices: ['Pods', 'Services', 'Deployments', 'ConfigMaps', 'Secrets'],
            description: 'Select Kubernetes concept to explore'
        )
        choice(
            name: 'LEARNING_LEVEL',
            choices: ['Beginner', 'Intermediate', 'Advanced'],
            description: 'Select your learning level'
        )
        string(
            name: 'NAMESPACE',
            defaultValue: 'k8s-learning',
            description: 'Kubernetes namespace for resources'
        )
        string(
            name: 'K8S_VERSION',
            defaultValue: '1.28',
            description: 'Kubernetes version to use'
        )
        booleanParam(
            name: 'INTERACTIVE_DEMO',
            defaultValue: true,
            description: 'Enable interactive demonstrations?'
        )
        booleanParam(
            name: 'HANDS_ON_LAB',
            defaultValue: true,
            description: 'Enable hands-on lab exercises?'
        )
    }

    stages {
        stage('üìã K8s Commander Setup') {
            steps {
                script {
                    echo "üöÄ Starting K8s Commander learning journey..."
                    echo ""
                    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                    echo "‚ïë                    üöÄ K8S COMMANDER SETUP                                   ‚ïë"
                    echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
                    echo "‚ïë  üéØ Learning Configuration:"
                    echo "‚ïë     ‚Ä¢ Concept: ${params.K8S_CONCEPT}"
                    echo "‚ïë     ‚Ä¢ Level: ${params.LEARNING_LEVEL}"
                    echo "‚ïë     ‚Ä¢ Namespace: ${params.NAMESPACE}"
                    echo "‚ïë     ‚Ä¢ K8s Version: ${params.K8S_VERSION}"
                    echo "‚ïë     ‚Ä¢ Interactive Demo: ${params.INTERACTIVE_DEMO}"
                    echo "‚ïë     ‚Ä¢ Hands-on Lab: ${params.HANDS_ON_LAB}"
                    echo "‚ïë"
                    echo "‚ïë  üèóÔ∏è  Building K8s Commander application..."
                    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
                }
                
                checkout scm
            }
        }
        
        stage('üîç K8s Concept Analysis') {
            steps {
                script {
                    echo "üîç Analyzing Kubernetes concept: ${params.K8S_CONCEPT}"
                    echo ""
                    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                    echo "‚ïë                    üîç K8S CONCEPT ANALYSIS                                   ‚ïë"
                    echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
                    
                    sh '''
                        echo "‚ïë  üìö Concept: ${K8S_CONCEPT}"
                        echo "‚ïë  üìñ Level: ${LEARNING_LEVEL}"
                        echo "‚ïë  üè∑Ô∏è  Namespace: ${NAMESPACE}"
                        echo "‚ïë  üî¢ Version: ${K8S_VERSION}"
                        echo "‚ïë"
                        echo "‚ïë  üéØ Learning Objectives:"
                        case "${K8S_CONCEPT}" in
                            "Pods")
                                echo "‚ïë     ‚Ä¢ Understand Pod lifecycle"
                                echo "‚ïë     ‚Ä¢ Learn Pod networking"
                                echo "‚ïë     ‚Ä¢ Practice Pod management"
                                ;;
                            "Services")
                                echo "‚ïë     ‚Ä¢ Master Service types"
                                echo "‚ïë     ‚Ä¢ Learn load balancing"
                                echo "‚ïë     ‚Ä¢ Practice service discovery"
                                ;;
                            "Deployments")
                                echo "‚ïë     ‚Ä¢ Understand rolling updates"
                                echo "‚ïë     ‚Ä¢ Learn scaling strategies"
                                echo "‚ïë     ‚Ä¢ Practice deployment management"
                                ;;
                            "ConfigMaps")
                                echo "‚ïë     ‚Ä¢ Learn configuration management"
                                echo "‚ïë     ‚Ä¢ Practice data injection"
                                echo "‚ïë     ‚Ä¢ Understand best practices"
                                ;;
                            "Secrets")
                                echo "‚ïë     ‚Ä¢ Master secret management"
                                echo "‚ïë     ‚Ä¢ Learn encryption at rest"
                                echo "‚ïë     ‚Ä¢ Practice secure deployments"
                                ;;
                        esac
                        echo "‚ïë"
                        echo "‚ïë  ‚úÖ Concept analysis complete!"
                        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
                    '''
                }
            }
        }
        
        stage('üéÆ Interactive Demo Creation') {
            when {
                expression { params.INTERACTIVE_DEMO == true }
            }
            steps {
                script {
                    echo "üéÆ Creating interactive K8s demonstration..."
                    echo ""
                    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                    echo "‚ïë                    üéÆ INTERACTIVE DEMO CREATION                             ‚ïë"
                    echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
                    
                    sh '''
                        echo "‚ïë  üéØ Creating interactive K8s demo for: ${K8S_CONCEPT}"
                        echo "‚ïë  üìÅ Setting up demo environment..."
                        
                        # Create demo directory
                        mkdir -p k8s-demo
                        
                        # Create YAML files based on concept
                        case "${K8S_CONCEPT}" in
                            "Pods")
                                cat > k8s-demo/pod-demo.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
    environment: demo
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
EOF
                                echo "‚ïë     ‚úÖ Created pod-demo.yaml"
                                ;;
                            "Services")
                                cat > k8s-demo/service-demo.yaml << 'EOF'
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
  labels:
    app: nginx
spec:
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
  type: ClusterIP
EOF
                                echo "‚ïë     ‚úÖ Created service-demo.yaml"
                                ;;
                            "Deployments")
                                cat > k8s-demo/deployment-demo.yaml << 'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "250m"
          limits:
            memory: "128Mi"
            cpu: "500m"
EOF
                                echo "‚ïë     ‚úÖ Created deployment-demo.yaml"
                                ;;
                        esac
                        
                        echo "‚ïë  üéÆ Interactive demo files created!"
                        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
                    '''
                }
            }
        }
        
        stage('üî¨ Hands-on Lab Setup') {
            when {
                expression { params.HANDS_ON_LAB == true }
            }
            steps {
                script {
                    echo "üî¨ Setting up hands-on lab exercises..."
                    echo ""
                    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                    echo "‚ïë                    üî¨ HANDS-ON LAB SETUP                                    ‚ïë"
                    echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
                    
                        sh '''
                        echo "‚ïë  üß™ Creating hands-on lab for: ${K8S_CONCEPT}"
                        echo "‚ïë  üìÅ Setting up lab environment..."
                        
                        # Create lab directory
                        mkdir -p k8s-lab
                        
                        # Create lab exercises
                        cat > k8s-lab/lab-instructions.md << 'EOF'
# K8s Commander Lab: ${K8S_CONCEPT}

## Lab Objectives
- Understand ${K8S_CONCEPT} concepts
- Practice hands-on exercises
- Learn best practices

## Exercises
1. Create a ${K8S_CONCEPT} resource
2. Verify the resource is running
3. Test the resource functionality
4. Clean up resources

## Commands to Try
```bash
# Create the resource
kubectl apply -f ${K8S_CONCEPT}-demo.yaml

# Check status
kubectl get ${K8S_CONCEPT}

# Describe the resource
kubectl describe ${K8S_CONCEPT} nginx-${K8S_CONCEPT,,}

# Clean up
kubectl delete -f ${K8S_CONCEPT}-demo.yaml
```
EOF
                        
                        echo "‚ïë     ‚úÖ Created lab instructions"
                        echo "‚ïë  üî¨ Hands-on lab setup complete!"
                        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
                    '''
                }
            }
        }
        
        stage('üê≥ K8s Commander App Build') {
            steps {
                script {
                    echo "üê≥ Building K8s Commander web application..."
                    echo ""
                    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                    echo "‚ïë                    üê≥ K8S COMMANDER APP BUILD                               ‚ïë"
                    echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
                    
                        sh '''
                        echo "‚ïë  üèóÔ∏è  Building K8s Commander Docker image..."
                        
                        # Find available port (avoiding Jenkins on 8080)
                        WEBAPP_PORT=8081
                        MAX_ATTEMPTS=50
                        ATTEMPTS=0
                        
                        while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
                            # Check if port is in use by netstat
                            if netstat -tuln 2>/dev/null | grep -q ":$WEBAPP_PORT "; then
                                echo "‚ïë     ‚Ä¢ Port $WEBAPP_PORT in use by netstat, trying next..."
                                WEBAPP_PORT=$((WEBAPP_PORT + 1))
                                ATTEMPTS=$((ATTEMPTS + 1))
                                continue
                            fi
                            
                            # Check if port is in use by ss command
                            if ss -tuln 2>/dev/null | grep -q ":$WEBAPP_PORT "; then
                                echo "‚ïë     ‚Ä¢ Port $WEBAPP_PORT in use by ss, trying next..."
                                WEBAPP_PORT=$((WEBAPP_PORT + 1))
                                ATTEMPTS=$((ATTEMPTS + 1))
                                continue
                            fi
                            
                            # Check if port is in use by lsof
                            if lsof -i :$WEBAPP_PORT 2>/dev/null | grep -q LISTEN; then
                                echo "‚ïë     ‚Ä¢ Port $WEBAPP_PORT in use by lsof, trying next..."
                                WEBAPP_PORT=$((WEBAPP_PORT + 1))
                                ATTEMPTS=$((ATTEMPTS + 1))
                                continue
                            fi
                            
                            # Check if port is in use by Docker containers
                            if docker ps --format "{{.Ports}}" 2>/dev/null | grep -q ":$WEBAPP_PORT->"; then
                                echo "‚ïë     ‚Ä¢ Port $WEBAPP_PORT in use by Docker, trying next..."
                                WEBAPP_PORT=$((WEBAPP_PORT + 1))
                                ATTEMPTS=$((ATTEMPTS + 1))
                                continue
                            fi
                            
                            # Port is available
                            echo "‚ïë     ‚Ä¢ Found available port: $WEBAPP_PORT"
                            break
                        done
                        
                        if [ $ATTEMPTS -ge $MAX_ATTEMPTS ]; then
                            echo "‚ïë  ‚ùå Could not find available port after $MAX_ATTEMPTS attempts"
                            exit 1
                        fi
                        
                        echo "‚ïë  üåê Using port: $WEBAPP_PORT"
                        
                        # Create Dockerfile for K8s Commander app
                        cat > Dockerfile << 'EOF'
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    curl \\
    && rm -rf /var/lib/apt/lists/*

# Create the K8s Commander application
RUN cat > app.py << 'PYEOF'
#!/usr/bin/env python3
import os
import time
import json
from http.server import HTTPServer, SimpleHTTPRequestHandler
from datetime import datetime

class K8sCommanderHandler(SimpleHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/api/status':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            status = {
                'status': 'running',
                'concept': os.environ.get('K8S_CONCEPT', 'Pods'),
                'level': os.environ.get('LEARNING_LEVEL', 'Beginner'),
                'namespace': os.environ.get('NAMESPACE', 'k8s-learning'),
                'k8s_version': os.environ.get('K8S_VERSION', '1.28'),
                'interactive_demo': os.environ.get('INTERACTIVE_DEMO', 'true'),
                'hands_on_lab': os.environ.get('HANDS_ON_LAB', 'true'),
                'timestamp': datetime.now().isoformat(),
                'uptime': int(time.time() - start_time)
            }
            self.wfile.write(json.dumps(status, indent=2).encode())
        elif self.path == '/api/concept':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            concept = os.environ.get('K8S_CONCEPT', 'Pods')
            concept_info = {
                'Pods': {
                    'description': 'The smallest deployable unit in Kubernetes',
                    'purpose': 'Run containers and manage their lifecycle',
                    'examples': ['nginx-pod', 'redis-pod', 'mysql-pod']
                },
                'Services': {
                    'description': 'Network abstraction for Pods',
                    'purpose': 'Enable communication between Pods',
                    'examples': ['nginx-service', 'api-service', 'db-service']
                },
                'Deployments': {
                    'description': 'Manages Pod replicas and updates',
                    'purpose': 'Ensure desired state and rolling updates',
                    'examples': ['web-deployment', 'api-deployment', 'worker-deployment']
                },
                'ConfigMaps': {
                    'description': 'Store configuration data',
                    'purpose': 'Separate configuration from application code',
                    'examples': ['app-config', 'db-config', 'api-config']
                },
                'Secrets': {
                    'description': 'Store sensitive data securely',
                    'purpose': 'Manage passwords, tokens, and certificates',
                    'examples': ['db-secret', 'api-key', 'tls-cert']
                }
            }
            
            self.wfile.write(json.dumps(concept_info.get(concept, {}), indent=2).encode())
        elif self.path == '/api/learning-path':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            level = os.environ.get('LEARNING_LEVEL', 'Beginner')
            learning_path = {
                'Beginner': [
                    'Learn basic K8s concepts',
                    'Understand Pod lifecycle',
                    'Practice with simple deployments',
                    'Explore basic networking'
                ],
                'Intermediate': [
                    'Master Service types',
                    'Learn advanced Pod patterns',
                    'Practice rolling updates',
                    'Explore configuration management'
                ],
                'Advanced': [
                    'Design complex architectures',
                    'Master security patterns',
                    'Optimize resource usage',
                    'Implement monitoring'
                ]
            }
            
            self.wfile.write(json.dumps(learning_path.get(level, []), indent=2).encode())
        else:
            # Serve the main HTML page
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            
            html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K8s Commander - {os.environ.get('K8S_CONCEPT', 'Pods')} Learning</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }}
        .container {{ max-width: 1200px; margin: 0 auto; padding: 20px; }}
        .header {{
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }}
        .header h1 {{ font-size: 3em; margin-bottom: 10px; color: white; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); }}
        .dashboard {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }}
        .card {{
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
        }}
        .card:hover {{ transform: translateY(-5px); }}
        .status {{ color: #4CAF50; font-weight: bold; }}
        .concept-highlight {{ color: #2196F3; font-weight: bold; }}
        .level-badge {{
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            color: white;
        }}
        .beginner {{ background: #4CAF50; }}
        .intermediate {{ background: #FF9800; }}
        .advanced {{ background: #F44336; }}
        .api-section {{ margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 10px; }}
        .api-endpoint {{ margin: 10px 0; padding: 10px; background: white; border-radius: 5px; }}
        .api-endpoint code {{ background: #e0e0e0; padding: 2px 5px; border-radius: 3px; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ K8s Commander</h1>
            <p>Mastering {os.environ.get('K8S_CONCEPT', 'Pods')} in Kubernetes</p>
        </div>
        
        <div class="dashboard">
            <div class="card">
                <h3>üéØ Current Focus</h3>
                <p><strong>Concept:</strong> <span class="concept-highlight">{os.environ.get('K8S_CONCEPT', 'Pods')}</span></p>
                <p><strong>Level:</strong> <span class="level-badge {os.environ.get('LEARNING_LEVEL', 'Beginner').lower()}">{os.environ.get('LEARNING_LEVEL', 'Beginner')}</span></p>
                <p><strong>Namespace:</strong> {os.environ.get('NAMESPACE', 'k8s-learning')}</p>
                <p><strong>K8s Version:</strong> {os.environ.get('K8S_VERSION', '1.28')}</p>
            </div>
            
            <div class="card">
                <h3>üéÆ Interactive Features</h3>
                <p><strong>Demo Mode:</strong> <span class="status">{'‚úÖ Enabled' if os.environ.get('INTERACTIVE_DEMO', 'true').lower() == 'true' else '‚ùå Disabled'}</span></p>
                <p><strong>Lab Mode:</strong> <span class="status">{'‚úÖ Enabled' if os.environ.get('HANDS_ON_LAB', 'true').lower() == 'true' else '‚ùå Disabled'}</span></p>
                <p><strong>Status:</strong> <span class="status">‚úÖ Running</span></p>
            </div>
            
            <div class="card">
                <h3>üìä Live Metrics</h3>
                <p><strong>Current Time:</strong> <span id="currentTime"></span></p>
                <p><strong>Uptime:</strong> <span id="uptime">Loading...</span></p>
                <p><strong>API Status:</strong> <span class="status">‚úÖ Active</span></p>
            </div>
            
            <div class="card">
                <h3>üîó API Endpoints</h3>
                <div class="api-section">
                    <div class="api-endpoint">
                        <strong>Status:</strong> <code>GET /api/status</code>
                    </div>
                    <div class="api-endpoint">
                        <strong>Concept Info:</strong> <code>GET /api/concept</code>
                    </div>
                    <div class="api-endpoint">
                        <strong>Learning Path:</strong> <code>GET /api/learning-path</code>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        function updateTime() {{
            document.getElementById('currentTime').textContent = new Date().toLocaleTimeString();
        }}
        
        function updateUptime() {{
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {{
                    document.getElementById('uptime').textContent = data.uptime + ' seconds';
                }});
        }}
        
        updateTime();
        updateUptime();
        setInterval(updateTime, 1000);
        setInterval(updateUptime, 5000);
    </script>
</body>
</html>
"""
            self.wfile.write(html_content.encode())
    
    def log_message(self, format, *args):
        # Suppress default logging
        pass

# Start the server
start_time = time.time()
server = HTTPServer(('0.0.0.0', int(os.environ.get('EXPOSE_PORT', '8080'))), K8sCommanderHandler)
print(f"K8s Commander server starting on port {os.environ.get('EXPOSE_PORT', '8080')}")
server.serve_forever()
PYEOF

# Set environment variables
ENV K8S_CONCEPT="${K8S_CONCEPT}"
ENV LEARNING_LEVEL="${LEARNING_LEVEL}"
ENV NAMESPACE="${NAMESPACE}"
ENV K8S_VERSION="${K8S_VERSION}"
ENV INTERACTIVE_DEMO="${INTERACTIVE_DEMO}"
ENV HANDS_ON_LAB="${HANDS_ON_LAB}"
ENV EXPOSE_PORT="${WEBAPP_PORT}"

# Expose port
EXPOSE ${WEBAPP_PORT}

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:${WEBAPP_PORT}/api/status || exit 1

# Run the application
CMD ["python3", "app.py"]
EOF
                        
                        echo "‚ïë     ‚úÖ Dockerfile created"
                        
                        # Build Docker image
                        IMAGE_NAME="k8s-commander-${BUILD_NUMBER}"
                        echo "‚ïë  üèóÔ∏è  Building image: $IMAGE_NAME"
                        docker build -t $IMAGE_NAME .
                        
                        echo "‚ïë     ‚úÖ Docker image built successfully"
                        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
                    '''
                }
            }
        }
        
        stage('üöÄ K8s Commander Deployment') {
            steps {
                script {
                    echo "üöÄ Deploying K8s Commander application..."
                    echo ""
                    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                    echo "‚ïë                    üöÄ K8S COMMANDER DEPLOYMENT                              ‚ïë"
                    echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
                    
                        sh '''
                        # Clean up any existing k8s-commander containers first
                        echo "‚ïë  üßπ Cleaning up existing containers..."
                        docker ps -a --filter "name=k8s-commander" --format "{{.Names}}" | xargs -r docker stop 2>/dev/null || true
                        docker ps -a --filter "name=k8s-commander" --format "{{.Names}}" | xargs -r docker rm 2>/dev/null || true
                        
                        # Also clean up any processes using ports 8081-8090
                        echo "‚ïë  üßπ Cleaning up port usage..."
                        port=8081
                        while [ $port -le 8090 ]; do
                            port_in_use=false
                            
                            # Check if port is in use by any method
                            if netstat -tuln 2>/dev/null | grep -q ":$port "; then
                                port_in_use=true
                            elif ss -tuln 2>/dev/null | grep -q ":$port "; then
                                port_in_use=true
                            elif lsof -i :$port 2>/dev/null | grep -q LISTEN; then
                                port_in_use=true
                            fi
                            
                            if [ "$port_in_use" = true ]; then
                                echo "‚ïë     ‚Ä¢ Port $port is in use, attempting to free it..."
                                # Try multiple methods to free the port
                                lsof -ti:$port 2>/dev/null | xargs -r kill -9 2>/dev/null || true
                                fuser -k $port/tcp 2>/dev/null || true
                                sleep 1
                            fi
                            
                            port=$((port + 1))
                        done
                        
                        # Wait for cleanup to complete
                        echo "‚ïë  ‚è≥ Waiting for cleanup to complete..."
                        sleep 3
                        
                        # Run cleanup script as fallback if available
                        if [ -f "cleanup.py" ]; then
                            echo "‚ïë  üßπ Running additional cleanup script..."
                            python3 cleanup.py > /dev/null 2>&1 || true
                        fi
                        
                        # Find available port with more thorough checking
                        WEBAPP_PORT=8081
                        MAX_ATTEMPTS=50
                        ATTEMPTS=0
                        
                        while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
                            # Check if port is in use by netstat
                            if netstat -tuln 2>/dev/null | grep -q ":$WEBAPP_PORT "; then
                                echo "‚ïë     ‚Ä¢ Port $WEBAPP_PORT in use by netstat, trying next..."
                                WEBAPP_PORT=$((WEBAPP_PORT + 1))
                                ATTEMPTS=$((ATTEMPTS + 1))
                                continue
                            fi
                            
                            # Check if port is in use by ss command
                            if ss -tuln 2>/dev/null | grep -q ":$WEBAPP_PORT "; then
                                echo "‚ïë     ‚Ä¢ Port $WEBAPP_PORT in use by ss, trying next..."
                                WEBAPP_PORT=$((WEBAPP_PORT + 1))
                                ATTEMPTS=$((ATTEMPTS + 1))
                                continue
                            fi
                            
                            # Check if port is in use by lsof
                            if lsof -i :$WEBAPP_PORT 2>/dev/null | grep -q LISTEN; then
                                echo "‚ïë     ‚Ä¢ Port $WEBAPP_PORT in use by lsof, trying next..."
                                WEBAPP_PORT=$((WEBAPP_PORT + 1))
                                ATTEMPTS=$((ATTEMPTS + 1))
                                continue
                            fi
                            
                            # Check if port is in use by Docker containers
                            if docker ps --format "{{.Ports}}" 2>/dev/null | grep -q ":$WEBAPP_PORT->"; then
                                echo "‚ïë     ‚Ä¢ Port $WEBAPP_PORT in use by Docker, trying next..."
                                WEBAPP_PORT=$((WEBAPP_PORT + 1))
                                ATTEMPTS=$((ATTEMPTS + 1))
                                continue
                            fi
                            
                            # Port is available
                            echo "‚ïë  ‚úÖ Found available port: $WEBAPP_PORT"
                            break
                        done
                        
                        if [ $ATTEMPTS -ge $MAX_ATTEMPTS ]; then
                            echo "‚ïë  ‚ùå Could not find available port after $MAX_ATTEMPTS attempts"
                            echo "‚ïë  üîç Current port usage:"
                            netstat -tuln 2>/dev/null | grep ":808" | while read line; do echo "‚ïë     $line"; done
                            exit 1
                        fi
                        
                        IMAGE_NAME="k8s-commander-${BUILD_NUMBER}"
                        CONTAINER_NAME="k8s-commander-${BUILD_NUMBER}"
                        
                        echo "‚ïë  üöÄ Starting K8s Commander container..."
                        echo "‚ïë     ‚Ä¢ Image: $IMAGE_NAME"
                        echo "‚ïë     ‚Ä¢ Container: $CONTAINER_NAME"
                        echo "‚ïë     ‚Ä¢ Port: $WEBAPP_PORT"
                        
                        # Verify port is still available before starting container
                        echo "‚ïë  üîç Verifying port availability..."
                        
                        # Force kill any processes using the port
                        echo "‚ïë     üî´ Force killing any processes on port $WEBAPP_PORT..."
                        lsof -ti:$WEBAPP_PORT 2>/dev/null | xargs -r kill -9 2>/dev/null || true
                        fuser -k $WEBAPP_PORT/tcp 2>/dev/null || true
                        sleep 1
                        
                        if netstat -tuln 2>/dev/null | grep -q ":$WEBAPP_PORT " || \
                           ss -tuln 2>/dev/null | grep -q ":$WEBAPP_PORT " || \
                           lsof -i :$WEBAPP_PORT 2>/dev/null | grep -q LISTEN || \
                           docker ps --format "{{.Ports}}" 2>/dev/null | grep -q ":$WEBAPP_PORT->"; then
                            echo "‚ïë     ‚ùå Port $WEBAPP_PORT is still in use, finding new port..."
                            # Find a new port using simple loop
                            NEW_PORT=8081
                            while [ $NEW_PORT -le 8090 ]; do
                                if ! netstat -tuln 2>/dev/null | grep -q ":$NEW_PORT " && \
                                   ! ss -tuln 2>/dev/null | grep -q ":$NEW_PORT " && \
                                   ! lsof -i :$NEW_PORT 2>/dev/null | grep -q LISTEN && \
                                   ! docker ps --format "{{.Ports}}" 2>/dev/null | grep -q ":$NEW_PORT->"; then
                                    WEBAPP_PORT=$NEW_PORT
                                    echo "‚ïë     ‚úÖ Found new available port: $WEBAPP_PORT"
                                    break
                                fi
                                NEW_PORT=$((NEW_PORT + 1))
                            done
                            
                            if [ $NEW_PORT -gt 8090 ]; then
                                echo "‚ïë     ‚ùå No available ports found in range 8081-8090"
                                exit 1
                            fi
                        else
                            echo "‚ïë     ‚úÖ Port $WEBAPP_PORT is confirmed available"
                        fi
                        
                        # Run the container with retry mechanism
                        MAX_RETRIES=3
                        RETRY_COUNT=0
                        
                        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                            echo "‚ïë  üöÄ Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES to start container..."
                            
                            if docker run -d \\
                                --name $CONTAINER_NAME \\
                                -p $WEBAPP_PORT:$WEBAPP_PORT \\
                                -e K8S_CONCEPT="${K8S_CONCEPT}" \\
                                -e LEARNING_LEVEL="${LEARNING_LEVEL}" \\
                                -e NAMESPACE="${NAMESPACE}" \\
                                -e K8S_VERSION="${K8S_VERSION}" \\
                                -e INTERACTIVE_DEMO="${INTERACTIVE_DEMO}" \\
                                -e HANDS_ON_LAB="${HANDS_ON_LAB}" \\
                                -e EXPOSE_PORT="$WEBAPP_PORT" \\
                                $IMAGE_NAME; then
                                echo "‚ïë     ‚úÖ Container started successfully"
                                break
                            else
                                echo "‚ïë     ‚ùå Container start failed, attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
                                RETRY_COUNT=$((RETRY_COUNT + 1))
                                
                                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                                    echo "‚ïë     üîÑ Cleaning up and retrying..."
                                    docker rm -f $CONTAINER_NAME 2>/dev/null || true
                                    
                                    # Find a new port for retry - use a simple loop
                                    echo "‚ïë     üîç Finding new available port..."
                                    NEW_PORT=8081
                                    while [ $NEW_PORT -le 8090 ]; do
                                        # Check if port is available
                                        if ! netstat -tuln 2>/dev/null | grep -q ":$NEW_PORT " && \
                                           ! ss -tuln 2>/dev/null | grep -q ":$NEW_PORT " && \
                                           ! lsof -i :$NEW_PORT 2>/dev/null | grep -q LISTEN && \
                                           ! docker ps --format "{{.Ports}}" 2>/dev/null | grep -q ":$NEW_PORT->"; then
                                            WEBAPP_PORT=$NEW_PORT
                                            echo "‚ïë     üîÑ Trying new port: $WEBAPP_PORT"
                                            break
                                        fi
                                        NEW_PORT=$((NEW_PORT + 1))
                                    done
                                    
                                    if [ $NEW_PORT -gt 8090 ]; then
                                        echo "‚ïë     ‚ùå No available ports found for retry"
                                        exit 1
                                    fi
                                    
                                    sleep 2
                                else
                                    echo "‚ïë     ‚ùå All retry attempts failed"
                                    exit 1
                                fi
                            fi
                        done
                        
                        # Wait for container to start
                        sleep 5
                        
                        # Check if container is running
                        if docker ps | grep -q $CONTAINER_NAME; then
                            echo "‚ïë     ‚úÖ Container deployed: $CONTAINER_NAME"
                            echo "‚ïë     ‚úÖ Access: http://localhost:$WEBAPP_PORT"
                        else
                            echo "‚ïë     ‚ùå Container failed to start"
                            docker logs $CONTAINER_NAME
                            exit 1
                        fi
                        
                        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
                    '''
                }
            }
        }
        
        stage('üìä K8s Commander Monitoring') {
            steps {
                script {
                    echo "üìä Monitoring K8s Commander application..."
                    echo ""
                    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                    echo "‚ïë                    üìä K8S COMMANDER MONITORING                              ‚ïë"
                    echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
                    
                    sh '''
                        # Find the running container
                        CONTAINER_NAME="k8s-commander-${BUILD_NUMBER}"
                        
                        # Check if container is running and get its port
                        if docker ps --filter "name=$CONTAINER_NAME" --format "{{.Names}}" | grep -q "$CONTAINER_NAME"; then
                            # Get the port from the running container
                            WEBAPP_PORT=$(docker port $CONTAINER_NAME | head -1 | cut -d: -f2)
                            echo "‚ïë  ‚úÖ Found running container on port: $WEBAPP_PORT"
                        else
                            echo "‚ïë  ‚ùå Container $CONTAINER_NAME is not running"
                            exit 1
                        fi
                        
                        echo "‚ïë  üîç Checking application health..."
                        
                        # Test API endpoints
                        if curl -s http://localhost:$WEBAPP_PORT/api/status > /dev/null 2>&1; then
                            echo "‚ïë     ‚úÖ API Status: Healthy"
                            
                            # Get status data
                            STATUS_DATA=$(curl -s http://localhost:$WEBAPP_PORT/api/status)
                            echo "‚ïë     üìä Status Data:"
                            echo "$STATUS_DATA" | jq -r 'to_entries[] | "‚ïë        ‚Ä¢ " + .key + ": " + (.value | tostring)' 2>/dev/null || echo "‚ïë        ‚Ä¢ Raw: $STATUS_DATA"
                        else
                            echo "‚ïë     ‚ùå API Status: Unhealthy"
                        fi
                        
                        if curl -s http://localhost:$WEBAPP_PORT/api/concept > /dev/null 2>&1; then
                            echo "‚ïë     ‚úÖ Concept API: Working"
                        else
                            echo "‚ïë     ‚ùå Concept API: Failed"
                        fi
                        
                        if curl -s http://localhost:$WEBAPP_PORT/api/learning-path > /dev/null 2>&1; then
                            echo "‚ïë     ‚úÖ Learning Path API: Working"
                        else
                            echo "‚ïë     ‚ùå Learning Path API: Failed"
                        fi
                        
                        echo "‚ïë"
                        echo "‚ïë  üåê Access Information:"
                        echo "‚ïë     ‚Ä¢ Main App: http://localhost:$WEBAPP_PORT"
                        echo "‚ïë     ‚Ä¢ API Status: http://localhost:$WEBAPP_PORT/api/status"
                        echo "‚ïë     ‚Ä¢ Concept Info: http://localhost:$WEBAPP_PORT/api/concept"
                        echo "‚ïë     ‚Ä¢ Learning Path: http://localhost:$WEBAPP_PORT/api/learning-path"
                        echo "‚ïë"
                        echo "‚ïë  üéØ Learning Resources:"
                        echo "‚ïë     ‚Ä¢ YAML Files: k8s-demo/ directory"
                        echo "‚ïë     ‚Ä¢ Lab Exercises: k8s-lab/ directory"
                        echo "‚ïë     ‚Ä¢ Interactive Demo: Web application above"
                        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            script {
                echo ""
                echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                echo "‚ïë                    üéâ K8S COMMANDER COMPLETED!                               ‚ïë"
                echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
                echo "‚ïë  üéØ Learning Journey Summary:"
                echo "‚ïë     ‚Ä¢ Concept Explored: ${params.K8S_CONCEPT}"
                echo "‚ïë     ‚Ä¢ Learning Level: ${params.LEARNING_LEVEL}"
                echo "‚ïë     ‚Ä¢ Namespace: ${params.NAMESPACE}"
                echo "‚ïë     ‚Ä¢ K8s Version: ${params.K8S_VERSION}"
                echo "‚ïë     ‚Ä¢ Interactive Demo: ${params.INTERACTIVE_DEMO}"
                echo "‚ïë     ‚Ä¢ Hands-on Lab: ${params.HANDS_ON_LAB}"
                echo "‚ïë"
                echo "‚ïë  üåê Application Access:"
                echo "‚ïë     ‚Ä¢ Web Application: Available during pipeline execution"
                echo "‚ïë     ‚Ä¢ API Endpoints: Status, Concept, Learning Path"
                echo "‚ïë     ‚Ä¢ YAML Resources: k8s-demo/ directory"
                echo "‚ïë     ‚Ä¢ Lab Materials: k8s-lab/ directory"
                echo "‚ïë"
                echo "‚ïë  üöÄ Ready for Next Level:"
                echo "‚ïë     ‚Ä¢ Scenario 5: Jenkins CI/CD Mastery"
                echo "‚ïë     ‚Ä¢ Advanced Jenkins features"
                echo "‚ïë     ‚Ä¢ Production-ready CI/CD patterns"
                echo "‚ïë     ‚Ä¢ Then: Full Kubernetes deployment"
                echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
            }
        }
        success {
            script {
                echo "üéâ K8s Commander learning journey completed successfully!"
                echo "üèÜ You've mastered ${params.K8S_CONCEPT} concepts through Jenkins!"
            }
        }
        failure {
            script {
                echo "‚ùå K8s Commander encountered issues, but learning continues!"
                echo "üîÑ Retry the pipeline to continue your journey."
                
                // Clean up on failure
                sh '''
                    echo "üßπ Cleaning up after failure..."
                    docker ps -a --filter "name=k8s-commander" --format "{{.Names}}" | xargs -r docker stop 2>/dev/null || true
                    docker ps -a --filter "name=k8s-commander" --format "{{.Names}}" | xargs -r docker rm 2>/dev/null || true
                    if [ -f "cleanup.py" ]; then
                        python3 cleanup.py > /dev/null 2>&1 || true
                    fi
                '''
            }
        }
    }
}